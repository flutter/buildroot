#!/usr/bin/env python3
#
# Copyright 2017 The Dart project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Usage: tools/dart/create_updated_flutter_deps.py [-d dart/DEPS] [-f flutter/DEPS]
#
# This script parses existing flutter DEPS file, identifies all 'dart_' prefixed
# dependencies, looks up revision from dart DEPS file, updates those dependencies
# and rewrites flutter DEPS file.

import argparse
import os
import sys

DART_SCRIPT_DIR = os.path.dirname(sys.argv[0])
DART_ROOT = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../third_party/dart'))
FLUTTER_ROOT = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../flutter'))
MONOREPO_ROOT = os.path.realpath(os.path.join(DART_SCRIPT_DIR, '../../../monorepo'))

class VarImpl(object):
  def __init__(self, local_scope):
    self._local_scope = local_scope

  def Lookup(self, var_name):
    """Implements the Var syntax."""
    if var_name in self._local_scope.get("vars", {}):
      return self._local_scope["vars"][var_name]
    if var_name == 'host_os':
      return 'linux' # assume some default value
    if var_name == 'host_cpu':
      return 'x64' # assume some default value
    raise Exception("Var is not defined: %s" % var_name)


def ParseDepsFile(deps_file):
  local_scope = {}
  var = VarImpl(local_scope)
  global_scope = {
    'Var': var.Lookup,
    'deps_os': {},
  }
  # Read the content.
  with open(deps_file, 'r') as fp:
    deps_content = fp.read()

  # Eval the content.
  exec(deps_content, global_scope, local_scope)

  return (local_scope.get('vars', {}), local_scope.get('deps', {}))

def ParseArgs(args):
  args = args[1:]
  parser = argparse.ArgumentParser(
      description='A script to generate updated dart dependencies for flutter DEPS.')
  parser.add_argument('--dart_deps', '-d',
      type=str,
      help='Dart DEPS file.',
      default=os.path.join(DART_ROOT, 'DEPS'))
  parser.add_argument('--flutter_deps', '-f',
      type=str,
      help='Flutter DEPS file.',
      default=os.path.join(FLUTTER_ROOT, 'DEPS'))
  parser.add_argument('--monorepo_deps', '-m',
      type=str,
      help='Monorepo DEPS file.',
      default=os.path.join(MONOREPO_ROOT, 'DEPS'))
  parser.add_argument('--create_monorepo',
                      action='store_true',
                      help='Create monorepo DEPS file')
  parser.add_argument('--dart_commit',
                      type=str,
                      help='Set monorepo DEPS to check out this Dart commit.')
  parser.add_argument('--engine_commit',
                      type=str,
                      help='Set monorepo DEPS to check out this engine commit.')
  parser.add_argument('--flutter_commit',
                      type=str,
                      help='Set monorepo DEPS to check out this flutter commit.')
  return parser.parse_args(args)

def Main(argv):
  args = ParseArgs(argv)
  (new_vars, new_deps) = ParseDepsFile(args.dart_deps)
  (old_vars, old_deps) = ParseDepsFile(args.flutter_deps)
  output_file = args.monorepo_deps if args.create_monorepo else args.flutter_deps

  updated_vars = {}

  # Collect updated dependencies
  for (k,v) in sorted(old_vars.items()):
    if k not in ('dart_revision', 'dart_git') and k.startswith('dart_'):
      dart_key = k[len('dart_'):]
      if dart_key in new_vars:
        updated_revision = new_vars[dart_key].lstrip('@') if dart_key in new_vars else v
        updated_vars[k] = updated_revision

  # Write updated DEPS file to a side
  updatedfilename = output_file + ".new"
  updatedfile = open(updatedfilename, "w")
  file = open(args.flutter_deps)
  lines = file.readlines()
  i = 0

  create_monorepo = args.create_monorepo
  # Track status of all rewrites
  vars_updated = False
  sdk_download = False
  dart_pin = False
  pinned_monorepo_deps = False
  updated_dependencies = False

  while i < len(lines):
    updatedfile.write(lines[i])
    if lines[i].startswith("  'dart_revision':"):
      vars_updated = True
      i = i + 2
      updatedfile.writelines([
        '\n',
        '  # WARNING: DO NOT EDIT MANUALLY\n',
        '  # The lines between blank lines above and below are generated by a script. See create_updated_flutter_deps.py\n'])
      while i < len(lines) and len(lines[i].strip()) > 0:
        i = i + 1
      for (k, v) in sorted(updated_vars.items()):
        updatedfile.write("  '%s': '%s',\n" % (k, v))
      updatedfile.write('\n')

    elif (create_monorepo
       and lines[i].startswith('  # Download a prebuilt Dart SDK by default')
       and lines[i+1].startswith("  'download_dart_sdk': True,")):
        sdk_download = True
        updatedfile.write("  'download_dart_sdk': False,\n")
        i = i + 1

    elif (create_monorepo
          and lines[i].startswith('deps = {')
          and lines[i+1].startswith(
          "  'src': 'https://github.com/flutter/buildroot.git' + '@' + ")):
        pinned_monorepo_deps = True
        i = i + 1
        updatedfile.write(lines[i])
        for dependency in [('src/flutter', 'flutter_git', '/mirrors/engine', args.engine_commit),
                           ('src/third_party/dart', 'dart_git', '/sdk', args.dart_commit),
                           ('flutter', 'flutter_git', '/mirrors/flutter', args.flutter_commit),
                           ]:
          updatedfile.write("\n  '%s': Var('%s') + '%s' + '@' + '%s',\n" % dependency)

    elif ( create_monorepo
           and i < len(lines) - 3
          and lines[i] == '\n'
          and lines[i+1] == "  'src/third_party/dart':\n"
          and lines[i+2] == "   Var('dart_git') + '/sdk.git' + '@' + Var('dart_revision'),\n"):
      dart_pin = True
      i = i + 3

    elif lines[i].startswith("  # WARNING: Unused Dart dependencies"):
      updated_dependencies = True
      updatedfile.write('\n')
      i = i + 1
      while i < len(lines) and (lines[i].startswith("  # WARNING: end of dart dependencies") == 0):
        i = i + 1
      for (k, v) in sorted(old_deps.items()):
        if (k.startswith('src/third_party/dart/')):
          for (dart_k, dart_v) in (list(new_deps.items())):
            dart_k_suffix = dart_k[len('sdk/') if dart_k.startswith('sdk/') else 0:]
            if (k.endswith(dart_k_suffix)):
              if (isinstance(dart_v, str)):
                updated_value = dart_v.replace(new_vars["dart_git"], "Var('dart_git') + '/")
                updated_value = updated_value.replace(old_vars["chromium_git"], "Var('chromium_git') + '")

                plain_v = dart_k[dart_k.rfind('/') + 1:]
                # This dependency has to be special-cased here because the
                # repository name is not the same as the directory name.
                if plain_v == "quiver":
                  plain_v = "quiver-dart"
                if ('dart_' + plain_v + '_tag' in updated_vars):
                  updated_value = updated_value[:updated_value.rfind('@')] + "' + '@' + Var('dart_" + plain_v + "_tag')"
                elif ('dart_' + plain_v + '_rev' in updated_vars):
                  updated_value = updated_value[:updated_value.rfind('@')] + "' + '@' + Var('dart_" + plain_v + "_rev')"
                else:
                  updated_value = updated_value + "'"
              else:
                # Non-string values(dicts) copy verbatim
                updated_value = dart_v

              updatedfile.write("  '%s':\n   %s,\n\n" % (k, updated_value))
              break
      updatedfile.write(lines[i])
    i = i + 1

  # Rename updated DEPS file into a new DEPS file
  os.remove(output_file)
  os.rename(updatedfilename, output_file)

  if create_monorepo and not (vars_updated and
      sdk_download and
      dart_pin and
      pinned_monorepo_deps and
      updated_dependencies ):
    if not vars_updated:
      print("Could not find 'dart_revision' line.")
    if not sdk_download:
      print("Could not set download_dart_sdk to False.")
    if not dart_pin:
      print("Could not remove 'src/third_party/dart' dependency line.")
    if not pinned_monorepo_deps:
      print("Could not add flutter, engine, and dart dependencies.")
    if not updated_dependencies:
      print("Could not update third_party dependencies.")
    return 1
  return 0

if __name__ == '__main__':
  sys.exit(Main(sys.argv))
